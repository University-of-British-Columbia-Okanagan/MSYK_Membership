// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  firstName              String
  lastName               String
  email                  String  @unique
  password               String
  phone                  String
  address                String
  over18                 Boolean
  parentGuardianName     String?
  parentGuardianPhone    String?
  parentGuardianEmail    String?
  guardianSignedConsent  String?
  photoRelease           Boolean
  dataPrivacy            Boolean
  emergencyContactName   String
  emergencyContactPhone  String
  emergencyContactEmail  String
  trainingCardUserNumber Int

  // roleUser  Int @default(1)
  roleUserId             Int      @default(1) // Default to 1
  roleUser               RoleUser @relation(fields: [roleUserId], references: [id]) // Relation to RoleUser
  roleLevel Int @default(1)

  userWorkshops UserWorkshop[] // Many-to-many relationship with User
  equipmentbookings EquipmentBooking[] 
}

model RoleUser {
  id   Int    @id @default(autoincrement()) // Primary key with auto-increment
  name String @unique // Role name, e.g., "Admin" or "User"

  users User[] // Back-reference for the relation
}
// model Workshop {
//   id          Int      @id @default(autoincrement())
//   name        String
//   description String
//   price       Float
//   createdAt   DateTime @default(now())
//   updatedAt   DateTime @updatedAt
//   location    String
//   capacity    Int
//   type      String  // "workshop" or "orientation"
//   prerequisites Int[] @default([])

//   occurrences WorkshopOccurrence[] // Relationship to occurrences
//   userWorkshops UserWorkshop[] // Many-to-many relationship with User
// }

model Workshop {
  id          Int      @id @default(autoincrement())
  name        String
  description String
  price       Float
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  location    String
  capacity    Int
  type        String  // "workshop" or "orientation"
  // Remove the prerequisites Int[] field
  
  // Add relationships
  occurrences WorkshopOccurrence[] // Relationship to occurrences
  userWorkshops UserWorkshop[] // Many-to-many relationship with User
  
  // Add new relationships for prerequisites
  prerequisiteFor WorkshopPrerequisite[] @relation("PrerequisiteWorkshop")
  prerequisites   WorkshopPrerequisite[] @relation("WorkshopWithPrerequisite")
}

// Create the new WorkshopPrerequisite model
model WorkshopPrerequisite {
  id                Int      @id @default(autoincrement())
  workshopId        Int      // The workshop that has prerequisites
  prerequisiteId    Int      // The workshop that is a prerequisite
  
  // Relationships
  workshop          Workshop @relation("WorkshopWithPrerequisite", fields: [workshopId], references: [id], onDelete: Cascade)
  prerequisiteWorkshop Workshop @relation("PrerequisiteWorkshop", fields: [prerequisiteId], references: [id], onDelete: Cascade)
  
  // Ensure uniqueness - a workshop can only have the same prerequisite once
  @@unique([workshopId, prerequisiteId])
}

model WorkshopOccurrence {
  id          Int      @id @default(autoincrement())
  workshopId  Int
  startDate   DateTime
  endDate     DateTime
  startDatePST DateTime?
  endDatePST   DateTime?
  status     String  @default("active") // "open", "closed", "cancelled"

  workshop    Workshop @relation(fields: [workshopId], references: [id], onDelete: Cascade)
  userWorkshops UserWorkshop[] 

  @@unique([workshopId, id], name: "workshopOccurrence_workshop_id")
}


// prerequisites
  // - orientations or workshops (many to many)
  // - at least level 1 member
  // - not necessarily paid subscription as it only gives perks (discounts, etc)
  // 
  // users (many to many)
  //   user - orientation - result (Passed, Failed) (pass by default for workshop), date
  //
  // type: orientation or workshop

model UserWorkshop {
  id           Int      @id @default(autoincrement())
  userId       Int
  workshopId   Int
  occurrenceId Int      
  result       String   @default("passed")
  date         DateTime @default(now())

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  workshop     Workshop @relation(fields: [workshopId], references: [id], onDelete: Cascade)
  occurrence   WorkshopOccurrence @relation(fields: [occurrenceId], references: [id], onDelete: Cascade)  

  @@unique([userId, occurrenceId]) // Ensure a user cannot register for the same occurrence twice
}
model Equipment {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String
  availability Boolean @default(true) // Whether it's currently available for booking
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  bookings EquipmentBooking[] // One-to-many relationship with bookings
}

model EquipmentBooking {
  id           Int      @id @default(autoincrement())
  userId       Int
  equipmentId  Int
  startTime    DateTime
  endTime      DateTime
  status       String   @default("pending") // Can be "pending", "approved", "cancelled"
  
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  equipment   Equipment  @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@unique([equipmentId, startTime]) // Ensure one booking per equipment per time slot
}

model MembershipPlan {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String
  description String
  price       Float
  feature     Json
  accessHours Json // Stores allowed booking hours for limited access members (e.g., {"start": "09:00", "end": "18:00"})
}