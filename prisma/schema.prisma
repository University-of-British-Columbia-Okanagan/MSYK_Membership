// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  firstName             String
  lastName              String
  email                 String  @unique
  password              String
  phone                 String
  dateOfBirth           String
  emergencyContactName  String
  emergencyContactPhone String
  emergencyContactEmail String
  mediaConsent          Boolean
  dataPrivacy           Boolean
  communityGuidelines   Boolean
  operationsPolicy      Boolean

  // Role Connection
  roleUserId  Int      @default(1)
  roleUser    RoleUser @relation(fields: [roleUserId], references: [id])
  roleLevel   Int      @default(1)
  allowLevel4 Boolean  @default(false)

  avatarUrl               String?
  waiverSignature         String?
  membershipStatus        String    @default("active") // "active", "revoked"
  membershipRevokedAt     DateTime?
  membershipRevokedReason String?

  brivoPersonId    String?  @unique
  brivoLastSyncedAt DateTime?
  brivoSyncError   String?

  // Relationships
  userWorkshops          UserWorkshop[]
  equipmentbookings      EquipmentBooking[]
  userMemberships        UserMembership[]
  userMembershipForms    UserMembershipForm[]
  paymentInformation     UserPaymentInformation?
  issuesReported         Issue[]
  volunteers             Volunteer[]
  volunteerHours         VolunteerTimetable[]
  workshopCancellations  WorkshopCancelledRegistration[]
  equipmentCancellations EquipmentCancelledBooking[]
  accessCards            AccessCard[]
  accessLogs             AccessLog[]
}

model AccessCard {
  id          String @id
  userId      Int?
  permissions Int[]

  brivoCredentialId String? @unique
  brivoMobilePassId String? @unique

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  accessLogs AccessLog[]

  @@index([userId])
}

model Volunteer {
  id             Int       @id @default(autoincrement())
  userId         Int
  volunteerStart DateTime  @default(now())
  volunteerEnd   DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VolunteerTimetable {
  id             Int      @id @default(autoincrement())
  userId         Int
  startTime      DateTime
  endTime        DateTime
  description    String
  status         String   @default("pending") // "pending", "approved", "denied", "resolved"
  previousStatus String?
  isResubmission Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startTime])
}

model RoleUser {
  id   Int    @id @default(autoincrement()) // Primary key with auto-increment
  name String @unique // Role name, e.g., "Admin" or "User"

  users User[] // Back-reference for the relation
}

model WorkshopPrerequisite {
  id             Int @id @default(autoincrement())
  workshopId     Int // The workshop that has prerequisites
  prerequisiteId Int // The workshop that is a prerequisite

  // Relationships
  workshop             Workshop @relation("WorkshopWithPrerequisite", fields: [workshopId], references: [id], onDelete: Cascade)
  prerequisiteWorkshop Workshop @relation("PrerequisiteWorkshop", fields: [prerequisiteId], references: [id], onDelete: Cascade)

  // Ensure uniqueness - a workshop can only have the same prerequisite once
  @@unique([workshopId, prerequisiteId])
}

model EquipmentPrerequisite {
  id                     Int @id @default(autoincrement())
  equipmentId            Int // The equipment that has prerequisites
  workshopPrerequisiteId Int // The workshop (orientation) that is a prerequisite

  // Relationships
  equipment            Equipment @relation("EquipmentWithPrerequisite", fields: [equipmentId], references: [id], onDelete: Cascade)
  prerequisiteWorkshop Workshop  @relation("EquipmentPrerequisiteWorkshop", fields: [workshopPrerequisiteId], references: [id], onDelete: Cascade)

  // Ensure uniqueness - an equipment can only have the same prerequisite once
  @@unique([equipmentId, workshopPrerequisiteId])
}

model Workshop {
  id                 Int      @id @default(autoincrement())
  name               String
  description        String
  price              Float
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  location           String
  capacity           Int
  type               String // "workshop" or "orientation"
  imageUrl           String?
  hasPriceVariations Boolean  @default(false)
  cancellationPolicy String   @default("Can't make it? Email info@makerspaceyk.com. Full refunds are only available if canceled within 48 hours of registration.")
  registrationCutoff Int      @default(60) // Registration cut-off in minutes before the workshop starts

  // Relationships
  occurrences           WorkshopOccurrence[] // Relationship to occurrences
  userWorkshops         UserWorkshop[] // Many-to-many relationship with User
  equipmentBookings     EquipmentBooking[]
  workshopCancellations WorkshopCancelledRegistration[]

  // Prerequisite relationships
  prerequisiteFor WorkshopPrerequisite[] @relation("PrerequisiteWorkshop")
  prerequisites   WorkshopPrerequisite[] @relation("WorkshopWithPrerequisite")

  equipmentPrerequisites EquipmentPrerequisite[] @relation("EquipmentPrerequisiteWorkshop")

  priceVariations WorkshopPriceVariation[]
}

model WorkshopOccurrence {
  id            Int       @id @default(autoincrement())
  workshopId    Int
  startDate     DateTime
  endDate       DateTime
  startDatePST  DateTime?
  endDatePST    DateTime?
  status        String    @default("active") // "open", "closed", "cancelled"
  connectId     Int? // For multi-day workshop tracking
  offerId       Int       @default(1)
  googleEventId String?

  // Relationships
  workshop              Workshop                        @relation(fields: [workshopId], references: [id], onDelete: Cascade)
  userWorkshops         UserWorkshop[]
  equipmentSlots        EquipmentSlot[] // This ensures each workshop occurrence can have multiple equipment slots.
  workshopCancellations WorkshopCancelledRegistration[]

  @@unique([workshopId, id], name: "workshopOccurrence_workshop_id")
}

model Equipment {
  id           Int                @id @default(autoincrement())
  name         String
  description  String?
  price        Float
  availability Boolean            @default(true)
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  imageUrl     String?
  slots        EquipmentSlot[]
  bookings     EquipmentBooking[]

  prerequisites EquipmentPrerequisite[]     @relation("EquipmentWithPrerequisite")
  cancellations EquipmentCancelledBooking[]
}

model EquipmentSlot {
  id          Int       @id @default(autoincrement())
  equipmentId Int
  equipment   Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  startTime   DateTime
  endTime     DateTime
  isAvailable Boolean  @default(true)
  isBooked    Boolean  @default(false)

  // Link to Workshops
  workshopOccurrenceId Int?
  workshopOccurrence   WorkshopOccurrence? @relation(fields: [workshopOccurrenceId], references: [id], onDelete: Cascade)

  bookings EquipmentBooking[] @relation("EquipmentSlotToBooking")
}

model EquipmentBooking {
  id              Int     @id @default(autoincrement())
  userId          Int
  equipmentId     Int
  slotId          Int
  workshopId      Int?
  status          String  @default("pending")
  bookedFor       String  @default("user") // "user" or "workshop"
  paymentIntentId String? // Stripe Payment Intent ID

  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  equipment Equipment     @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  slot      EquipmentSlot @relation(fields: [slotId], references: [id], onDelete: Cascade, name: "EquipmentSlotToBooking")
  workshop  Workshop?     @relation(fields: [workshopId], references: [id], onDelete: Cascade)

  // Removed unique constraint to allow cancelled bookings + new bookings for same slot
  // @@unique([slotId]) // Prevents double booking of slots
}

model UserWorkshop {
  id               Int      @id @default(autoincrement())
  userId           Int
  workshopId       Int
  occurrenceId     Int
  priceVariationId Int?
  result           String   @default("passed")
  date             DateTime @default(now())
  paymentIntentId  String? // Stripe Payment Intent ID

  user       User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  workshop   Workshop           @relation(fields: [workshopId], references: [id], onDelete: Cascade)
  occurrence WorkshopOccurrence @relation(fields: [occurrenceId], references: [id], onDelete: Cascade)

  priceVariation WorkshopPriceVariation? @relation("UserWorkshopPriceVariation", fields: [priceVariationId], references: [id], onDelete: SetNull)

  @@unique([userId, occurrenceId]) // Prevents duplicate registrations for the same occurrence
}

model WorkshopPriceVariation {
  id          Int    @id @default(autoincrement())
  workshopId  Int
  name        String
  price       Float
  description String
  capacity    Int
  status      String @default("active") // "active", "cancelled"

  // Relationships
  workshop              Workshop                        @relation(fields: [workshopId], references: [id], onDelete: Cascade)
  userWorkshops         UserWorkshop[]                  @relation("UserWorkshopPriceVariation")
  workshopCancellations WorkshopCancelledRegistration[]

  @@unique([workshopId, name]) // Prevent duplicate variation names for same workshop
}

model WorkshopCancelledRegistration {
  id                   Int      @id @default(autoincrement())
  userId               Int
  workshopId           Int
  workshopOccurrenceId Int
  priceVariationId     Int?
  registrationDate     DateTime
  cancellationDate     DateTime
  paymentIntentId      String? // Stripe Payment Intent ID
  resolved             Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relationships
  user               User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  workshop           Workshop                @relation(fields: [workshopId], references: [id], onDelete: Cascade)
  workshopOccurrence WorkshopOccurrence      @relation(fields: [workshopOccurrenceId], references: [id], onDelete: Cascade)
  priceVariation     WorkshopPriceVariation? @relation(fields: [priceVariationId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([workshopId])
  @@index([resolved])
  @@index([cancellationDate])
}

model EquipmentCancelledBooking {
  id              Int     @id @default(autoincrement())
  userId          Int
  equipmentId     Int
  paymentIntentId String? // The original Stripe payment intent for the entire booking

  // Equipment booking details
  totalSlotsBooked Int // Total number of slots in the original booking
  slotsRefunded    Int // Number of slots being refunded in this cancellation
  totalPricePaid   Float // Total amount paid for all slots (including tax)
  priceToRefund    Float // Amount to refund for the cancelled slots

  // Cancellation tracking
  cancellationDate  DateTime @default(now())
  eligibleForRefund Boolean // Calculated based on 2-day rule
  resolved          Boolean  @default(false)

  // Store the cancelled slot times as JSON for multiple bookings
  cancelledSlotTimes Json // Array of { startTime: DateTime, endTime: DateTime, slotId: Int }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  equipment Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([equipmentId])
  @@index([paymentIntentId])
}

model MembershipPlan {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title               String
  description         String
  price               Float // Price for monthly subscription
  price3Months        Float? // Price for 3-month subscription
  price6Months        Float? // Price for 6-month subscription
  priceYearly         Float? // Price for yearly subscription
  needAdminPermission Boolean @default(false)
  feature             Json

  userMemberships     UserMembership[]
  userMembershipForms UserMembershipForm[]
}

model UserMembership {
  id               Int      @id @default(autoincrement())
  userId           Int
  membershipPlanId Int
  date             DateTime @default(now())
  nextPaymentDate  DateTime
  status           String   @default("active") // "active", "ending", "cancelled", "inactive", "revoked"
  paymentIntentId  String? // Stripe Payment Intent ID
  billingCycle     String   @default("monthly") // "monthly", "quarterly", "semiannually", "yearly"

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  membershipPlan MembershipPlan @relation(fields: [membershipPlanId], references: [id], onDelete: Cascade)

  membershipForms UserMembershipForm[]
}

model UserMembershipForm {
  id                 Int      @id @default(autoincrement())
  userId             Int
  membershipPlanId   Int
  userMembershipId   Int?
  agreementSignature String // Encrypted signature data
  status             String   @default("pending") // "pending", "active", "inactive", "cancelled", "ending"
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  membershipPlan MembershipPlan  @relation(fields: [membershipPlanId], references: [id], onDelete: Cascade)
  userMembership UserMembership? @relation(fields: [userMembershipId], references: [id], onDelete: Cascade)
}

model UserPaymentInformation {
  id                    Int      @id @default(autoincrement())
  userId                Int      @unique
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripeCustomerId      String? // Stripe customer ID for payment processing
  stripePaymentMethodId String? // Stripe payment method ID
  cardholderName        String? // Name on card
  cardLast4             String? // Last 4 digits of the card
  cardExpiry            String? // Card expiry date in MM/YY format
  expMonth              Int? // Expiry month
  expYear               Int? // Expiry year
  billingAddressLine1   String?
  billingAddressLine2   String?
  billingCity           String?
  billingState          String?
  billingZip            String?
  billingCountry        String?
  email                 String? // Email associated with the payment method
  isDefault             Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
  @@index([stripeCustomerId])
}

model AdminSettings {
  id          Int      @id @default(autoincrement())
  key         String   @unique
  value       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Issue {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  title       String
  description String
  status      String @default("open") // "open", "in_progress", "resolved"
  priority    String @default("medium") // 1 to 5

  reportedById Int
  reportedBy   User @relation(fields: [reportedById], references: [id], onDelete: Cascade)

  screenshots IssueScreenshot[]

  @@index([reportedById])
}

model IssueScreenshot {
  id      Int    @id @default(autoincrement())
  issueId Int
  url     String

  issue Issue @relation(fields: [issueId], references: [id], onDelete: Cascade)

  @@index([issueId])
}

model AccessLog {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) // Timestamp of the log

  userId Int?
  user   User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  accessCardId String // Store access card UID
  accessCard   AccessCard @relation(fields: [accessCardId], references: [id], onDelete: Cascade)

  equipment String // Equipment name or door
  state     String // enter or exit

  @@index([userId])
  @@index([createdAt])
  @@index([accessCardId])
}
