/*
 * ESP32 WROOM RFID Access Control for MSYK Membership System
 * 
 * Hardware:
 * - ESP32 WROOM Module
 * - MFRC522 RFID Reader
 * 
 * MFRC522 Wiring to ESP32:
 * SDA/SS  -> GPIO 21
 * SCK     -> GPIO 18
 * MOSI    -> GPIO 23
 * MISO    -> GPIO 19
 * IRQ     -> Not connected
 * GND     -> GND
 * RST     -> GPIO 22
 * 3.3V    -> 3.3V
 */

#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include <set>

// Store active users in memory to prevent multiple enter reads
std::set<String> activeCards;

// WiFi credentials
const char* ssid = "MakerspaceYK";
const char* password = "after8pub";

// Server configuration
const char* serverUrl = "https://my.makerspaceyk.com";  // Replace with your server URL (e.g., https://msyk.example.com)
const char* apiEndpoint = "/access";                    // API endpoint for access control (note: NOT /api/access)

// JWT Access Token - This is generated by your server and contains the type and tag for this device
// The JWT should be signed with your JWT_SECRET and contain: { type: "door", tag: "main_entrance" }
// Generate this on your server using: jwt.sign({ type: "door", tag: "main_entrance" }, process.env.JWT_SECRET, { algorithm: "HS256" })
const char* accessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc0Rvb3IiOnRydWUsInR5cGUiOiJEb29yIiwidGFnIjoic2lnbl9pbl9raW9zayIsImlhdCI6MTc2MTM0OTc3NH0.Uq8_Mc1zfmVsE5Tm04chHbWus4jnHtfKzEb4cqwiovU";

// RFID pins
#define RST_PIN 22
#define SS_PIN  21

// Status LED pins (optional - use RGB LED for better feedback)
#define LED_GREEN 27   // Built-in LED or external green LED
#define LED_RED 4     // External red LED (optional)

// Door/Lock control
#define RELAY_PIN 5   // Relay to control door lock/strike

// Create MFRC522 instance
MFRC522 mfrc522(SS_PIN, RST_PIN);

// WiFi client for HTTPS
WiFiClientSecure client;

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n\n===========================================");
  Serial.println("MSYK ESP32 RFID Access Control System");
  Serial.println("===========================================\n");
  
  // Initialize pins
  pinMode(LED_GREEN, OUTPUT);
  pinMode(LED_RED, OUTPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(LED_GREEN, LOW);
  digitalWrite(LED_RED, LOW);
  digitalWrite(RELAY_PIN, LOW);
  
  // Initialize SPI bus
  SPI.begin();
  
  // Initialize MFRC522
  mfrc522.PCD_Init();
  delay(100);
  mfrc522.PCD_DumpVersionToSerial();
  Serial.println("\n RFID Reader initialized");
  Serial.println("Waiting for cards...\n");
  
  // Connect to WiFi
  connectWiFi();
  
  // Configure HTTPS client
  // IMPORTANT: For production, load the actual root CA certificate
  // For testing/development, you can use insecure mode
  client.setInsecure();  // Skip certificate validation (ONLY for testing!)
  
  // To use proper SSL certificate validation, use:
  // client.setCACert(root_ca);  // Uncomment and provide your CA certificate
  
  Serial.println(" System ready\n");

  blinkLED(LED_GREEN, 3, 150);  // Indicate ready status
}

void loop() {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("⚠ WiFi disconnected. Reconnecting...");
    digitalWrite(LED_RED, HIGH);
    connectWiFi();
    digitalWrite(LED_RED, LOW);
  }
  
  // Look for new cards
  if (!mfrc522.PICC_IsNewCardPresent()) {
    delay(50);
    return;
  }
  
  // Select one of the cards
  if (!mfrc522.PICC_ReadCardSerial()) {
    delay(50);
    return;
  }
  
  // Get UID as hex string (uppercase)
  String accessCardId = getRFIDString();
  Serial.println("\n========================================");
  Serial.println("Card detected!");
  Serial.print("Access Card ID: ");
  Serial.println(accessCardId);
  Serial.println("========================================");

  String state = activeCards.count(accessCardId) > 0 ? "exit" : "enter";
  Serial.print("Detected state: ");
  Serial.println(state);
  
  // Check access with server
  bool accessGranted = checkAccess(accessCardId, state);
  
  if (accessGranted) {
    if (state == "enter") {
        activeCards.insert(accessCardId);
        Serial.println("\n✓✓✓ ENTRY GRANTED ✓✓✓\n");
    } else {
        activeCards.erase(accessCardId);
        Serial.println("\n✓✓✓ EXIT GRANTED ✓✓✓\n");
    }
    grantAccess();
} else {
    activeCards.erase(accessCardId);
    Serial.println("\n✗✗✗ ACCESS DENIED ✗✗✗\n");
    denyAccess();
}
  
  // Halt PICC and stop crypto
  mfrc522.PICC_HaltA();
  mfrc522.PCD_StopCrypto1();
  
  // Prevent multiple reads of same card
  // Wait for card to be removed
  Serial.println("Remove card...");
  while (mfrc522.PICC_IsNewCardPresent()) {
    delay(100);
  }
  delay(1000);  // Additional delay before accepting next card
}

void connectWiFi() {
  Serial.print("Connecting to WiFi");
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✓ WiFi connected!");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    Serial.print("Signal strength: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm\n");
  } else {
    Serial.println("\n✗ WiFi connection failed!");
    Serial.println("Restarting ESP32...\n");
    delay(3000);
    ESP.restart();
  }
}

String getRFIDString() {
  String uid = "";
  for (byte i = 0; i < mfrc522.uid.size; i++) {
    if (mfrc522.uid.uidByte[i] < 0x10) {
      uid += "0";
    }
    uid += String(mfrc522.uid.uidByte[i], HEX);
  }
  uid.toUpperCase();  // Server expects uppercase hex
  return uid;
}

bool checkAccess(String accessCardId, String state) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("✗ Error: No WiFi connection");
    return false;
  }
  
  HTTPClient https;
  String url = String(serverUrl) + apiEndpoint;
  
  Serial.println("Verifying access with server...");
  Serial.print("URL: ");
  Serial.println(url);
  
  https.begin(client, url);
  https.addHeader("Content-Type", "application/x-www-form-urlencoded");
  https.setTimeout(10000);  // 10 second timeout
  
  // Create form data payload (application/x-www-form-urlencoded)
  // Initial state is 'enter' - server will verify permissions
  String postData = "accessCardId=" + accessCardId + 
                    "&accessToken=" + String(accessToken) + 
                    "&state=" + state;
  
  Serial.println("Sending request...");
  
  // Send POST request
  int httpResponseCode = https.POST(postData);
  
  bool accessGranted = false;
  
  if (httpResponseCode > 0) {
    String response = https.getString();
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    Serial.print("Response: ");
    Serial.println(response);
    
    if (httpResponseCode == 200) {
      // Parse JSON response
      StaticJsonDocument<512> responseDoc;
      DeserializationError error = deserializeJson(responseDoc, response);
      
      if (!error) {
        bool success = responseDoc["success"] | false;
        const char* message = responseDoc["message"] | "Unknown response";
        
        Serial.print("Success: ");
        Serial.println(success ? "true" : "false");
        Serial.print("Message: ");
        Serial.println(message);
        
        if (success) {
          accessGranted = true;
          
          // Extract user info from the decoded JWT data if available
          if (responseDoc.containsKey("data")) {
            const char* type = responseDoc["data"]["type"] | "unknown";
            const char* tag = responseDoc["data"]["tag"] | "unknown";
            
            Serial.println("\nAccess Details:");
            Serial.print("  Type: ");
            Serial.println(type);
            Serial.print("  Tag: ");
            Serial.println(tag);
          }
        } else {
          Serial.print("Denial reason: ");
          Serial.println(message);
        }
      } else {
        Serial.print("✗ JSON parsing error: ");
        Serial.println(error.c_str());
      }
    } else {
      Serial.println("✗ Server returned non-200 status");
    }
  } else {
    Serial.print("✗ HTTP Error: ");
    Serial.println(httpResponseCode);
    Serial.println(https.errorToString(httpResponseCode));
  }
  
  https.end();
  
  // No need to send second request - server logs on first request
  return accessGranted;
}

void grantAccess() {
  // Unlock door
  digitalWrite(RELAY_PIN, HIGH);
  
  // Green LED success pattern
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_GREEN, HIGH);
    delay(100);
    digitalWrite(LED_GREEN, LOW);
    delay(100);
  }
  
  // Optional: Add piezo buzzer for audio feedback
  // tone(BUZZER_PIN, 1000, 200);  // Success beep
  
  Serial.println("Door unlocked for 5 seconds...");
  
  // Keep door unlocked for 5 seconds
  delay(5000);
  
  // Lock door
  digitalWrite(RELAY_PIN, LOW);
  Serial.println("Door locked.");
}

void denyAccess() {
  // Red LED denial pattern
  digitalWrite(LED_RED, HIGH);
  for (int i = 0; i < 5; i++) {
    digitalWrite(LED_RED, HIGH);
    delay(80);
    digitalWrite(LED_RED, LOW);
    delay(80);
  }
  
  // Optional: Add piezo buzzer for audio feedback
  // tone(BUZZER_PIN, 400, 100);  // Error beep
  // delay(150);
  // tone(BUZZER_PIN, 400, 100);  // Error beep
}

void blinkLED(int pin, int times, int duration) {
  for (int i = 0; i < times; i++) {
    digitalWrite(pin, HIGH);
    delay(duration);
    digitalWrite(pin, LOW);
    delay(duration);
  }
}